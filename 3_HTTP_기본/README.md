# 3. HTTP 기본
## HTTP란
![페이커 모든 길은 저를 통합니다](./image/faker.png)

HTTP(Hyper Text Transfer Protocol)는 HTML 문서를 주고받는 것에서 시작됐지만 현재는 모든 것이 가능하다.

- HTML, TEXT
- IMAGE, 음성, 영상, 파일
- JSON, XML(API)

거의 모든 형태의 데이터 전송이 가능하다. 서버간에 데이터를 주고 받을 때도 대부분 HTTP를 사용한다. 대 HTTP 시대라고 할 수 있다. 실무에서 작업 시 TCP 프로토콜을 직접 연결해서 사용하는 경우는 거의 없다. 게임서버등 특수한 경우에만 사용된다.

### 역사
현재 가장 많이 다뤄지는 버전은 HTTP/1.1 버전이다. 대부분의 기능은 1.1 버전에 정의되어 있으며 2, 3 버전은 성능개선에 초점이 맞춰져 있다.

### 기반 프로토콜
- TCP: HTTP/1.1, HTTP/2
- UDP: HTTP/3

2, 3 버전이 급속도로 퍼지고 있지만 HTTP/1.1의 스펙을 먼저 이해해야 2, 3 버전의 이해를 높일 수 있다.

### 특징

- 클라이언트, 서버 구조를 가진다.
- 무상태 프로토콜(스테이리스), 비연결성
- HTTP 메시지
- 단순함, 확장 가능

## 클라이언트 서버 구조

- Request, Response 구조
- 클라이언트는 서버에 요청을 보내고, 서버는 응답을 대기한다.
- 서버는 요청에 대한 결과를 만들어 응답한다.

과거에는 클라이언트, 서버개념이 분리되지 않았다. 하지만 현재는 개념적으로 분리해서 이야기한다. 중요한 점은 비즈니스 로직, 데이터를 서버에서 제공하고, 클라이언트는 UI/UX에 집중한다. 분리를 통해 각자의 역활에 집중할 수 있다.

## 무상태 프로토콜

스테이스리스(stateless)

- 서버가 클라이언트의 상태를 보존하지 않는다.
- 장점: 서버 확장성이 높다. (스케일 아웃)
- 단점: 클라이언트가 추가 데이터를 전송한다.

### Stateful, Stateless
둘의 차이는 상태를 관리하는 방법이다.

- 상태유지: 중간에 다른 점원으로 바뀌면 안된다. 바뀔 때 상태정보를 다른 점원에게 미리 알려야 한다.
- 무상태: 중간에 다른 점원으로 교체가 가능하다.
	- 갑자기 고객이 증가해도 점원을 대거 투입할 수 있다.
	- 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.

무상태(Stateless)는 응답 서버를 쉽게 교체 가능하다. 따라서 확장성에 엄청난 차이를 보인다.

- 상태유지(Stateful)는 항상 같은 서버가 유지되어야 한다. 중간에 장애가 발생한다면 처음부터 다시 진행되어야 한다.
- 무상태(Stateless)는 필요하면 응답만 하면 된다. 중간에 장애가 발생한다면 다른 서버에서 처리하면 된다. 
	- 스케일 아웃에 유리하다. (이벤트가 진행되어야 한다면 장비를 늘린다.)

### 한계
실무에서 한계점을 보이는 경우도 있다. (무상태로 처리할 수 있는 경우와 무상태로 처리하지 못하는 경우도 있다.) 예를들어 로그인은 로그인 했다는 상태를 서버에 유지시킨다. 상태유지는 최소한 사용을(어쩔수 없는 경우) 권장한다. 또한 Stateless는 데이터를 많이 전송해야 한다는 단점이 있다.

- 애플리케이션을 설계할 때는 최대한 무상태로 설계하고 어쩔 수 없는 경우, 상태유지를 진행한다.

## 비 연결성(Connectionless)
클라이언트의 요청을 받고 서버는 응답 후 통신을 종료한다. 이는 최소한의 자원으로 서버를 운용할 수 있다.

### 특징

- HTTP는 기본적으로 연결을 유지하지 않는 모델이다.
- 일반적으로 초 단위 이하의 빠른 속도로 응답한다.
- 서버 자원을 효율적으로 사용할 수 있다.

### 한계와 극복

- TCP/IP 연결을 새로 맺어야 한다. - 3 way handshake 시간 추가
- 웹 브라우저로 사이트를 요청할 때 다양한 미디어 자원이 함께 다운로드 된다.
- 현재는 지속연결(Persistent Connections)로 문제를 해결한다.
> 🙅 Keep-Alive: 문서를 읽어도 명확하게 이해가 되지 않는 개념이다.
- HTTP/2, HTTP/3에서 더 많은 최적화가 이뤄졌다.

### 스테이스리스를 기억하자
서버개발자들이 어려워하는 업무에 속한다.

- 같은 시간에 딱 맞춰이뤄지는 대용량 트래픽
	- 예) 선착순 이벤트, 콘서트 예약, 수업 등록 

배운 개념(비 연결성)을 막론하고 해당 문제들을 해결하는 것은 물론 어렵다. 그렇지만 최대한 스테이스리스 설계하는 것이 중요하다. (어떻게든 머리를 쥐어짜서) 스테이스리스로 설계해야 대용량 트래픽이 몰려와도 대응할 수 있다. 최대한 무상태로 설계하고 어쩔 수 없는 경우에만 상태유지 설계를 권장한다.

## HTTP 메시지 구조
요청메시지와 응답메시지는 구조가 다르다.
```text
예) 요청 메시지
GET /search?q=hello&hl=ko HTTP/1.1
Host: www.google.com
# 공백

예) 응답 메시지
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3423

<html>
	<body>...</body>
</html>
```

```text
HTTP 메시지 구조
start-line 시작라인
header 헤더
empty line 공백라인 (CRLF)
message body
```

### 시작 라인
요청 메시지
- start-line: **request-line** / status-line
- **request-line**: method SP(공백) request-target SP HTTP-version CRLF(엔터)
- HTTP 메서드(GET: 조회)
  - 종류 : GET, POST, PUT, DELETE...
  - 서버가 수행해야 할 동작을 지정한다.
    - GET: 리소스 조회
    - POST: 요청 내역 처리
- 요청 대상(/search?q=hello&hl=ko)
	- absolute-path[?query] (절대경로[쿼리])
    - 절대경로란 `/` 으로 시작하는 경로를 의미한다.
    - 참고로 다른 유형의 경로지정 방법도 있다.
- HTTP Version


응답메시지

- start-line: request-line / **status-line**
- **status-line**: HTTP-version SP status-code SP reason-phrase CRLF

- HTTP 버전
- HTTP 상태코드: 요청 성공, 실패를 나타냄
  - 200: 성공
  - 400: 클라이언트 요청 오류
  - 500: 서버 내부 오류
- 이유 문구: 사람이 이해할 수 있는 짧은 상태코드 설명 글

### HTTP 헤더
- header-field = field-name":" OWS field-value OWS (OWS: 띄어쓰기 허용)
- 용도: HTTP 전송에 필요한 모든 부가정보
- 표준 헤더는 너무 많다.
- 필요시 임의 헤더를 추가할 수 있다.

### 메시지 바디
- 용도: 실제 전송할 데이터
- HTML 문서, 이미지, 영상, JSON 등등 byte로 표현할 수 있는 모든 데이터 전송 가능

## 정리: 모든 것이 HTTP다!

- HTTP 메세지에 모든 것을 전송 할 수 있다.
- HTTP/1.1을 기준으로 학습한다.
- 클라이언트 서버 구조
- 무상태 프로토콜(Stateless)
- HTTP 메시지
- 단순함, 확장 가능

![대 HTTP 시대](./image/http.jpeg)

결국 모든 것은 HTTP다. 바아흐로 대 HTTP 시대다.

